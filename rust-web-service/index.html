<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Building a web service with Rust, Postgres and Kafka</title>
		<link rel="stylesheet" href="../style.css">
		<link rel="stylesheet" href="style.css">
    <link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
    <link rel="manifest" href="../site.webmanifest">
  </head>
  <body class="article-page">
	  	<header>
			<div class="container">
				  <h1 class="glitch-text" data-text="A Rusty Web Service ü¶Ä">
              A Rusty Web Service ü¶Ä
				</h1>
        <span class="subtitle">
            Building a web service with Rust, Postgres and Kafka
        </span>
			</div>
			<div class="byline">
				<div class="container">
					<p>
						By <a href="https://twitter.com/chamooktweets">Adam Guest</a> - 1 August 2021
					</p>
				</div>
			</div>
		</header>
		<article class="container">
        <section class="intro">
            <p>
            After reading a whole 10 chapters of the <a href="https://doc.rust-lang.org/book/">üìï Rust Book</a>,
            I decided that the best way to continue learning would be to try building
            something with it. The opportunity came when my team and I needed a throwaway
            service with functionality that would be eventually handled by a third
            party, in order to provide a manual way for a user to enter that data into the
            system now. The service would be small enough that if everything goes wrong I
            can quickly rewrite it using .NET, and as it will definitely be replaced by new
            functionality in an existing system we can relax some of the more
            complicated-to-implement constraints around data/error handling.
            </p>
            <p>
                This service would need several capabilities:
            </p>
            <ul>
                <li>
                    provide http endpoints - <a href="https://actix.rs/">Actix</a> seems to be a solid,
                    mature option;
                </li>
                <li>
                    save data to a Postgres database - the common choice for this seems to be
                    <a href="https://diesel.rs/">Diesel</a>, but I have an irrational hatred of ORMs
                    so instead using <a href="https://github.com/sfackler/rust-postgres">tokio-postgres</a>
                    with <a href="https://crates.io/crates/deadpool-postgres">deadpool</a> for connection pooling;
                </li>
                <li>
                    send messages over Kafka - and
                    <a href="https://github.com/fede1024/rust-rdkafka">rust-rdkafka</a> appears to
                    be an excellent choice.
                </li>
            </ul>
            <p>
                This service will be responsible for storing data after receiving a http request and
                then raising an event that will be processed by another service. Later it will need
                to process and respond to follow up events about the data, but that is not covered
                in this article.
            </p>
            <p>
                With an understanding of the requirements, and an idea of the technology setup we're
                ready to bring <em>Sample Service</em> to life üë∂
            </p>
        </section>
        <section class="actix">
            <h2>
                HTTP Endpoint With Actix
            </h2>
            <h3>
                Hello World üëã
            </h3>
            <p>
                To start with, we can make a service that runs and responds with a static message on
                a single HTTP endpoint.
            </p>
            <p>
                After creating the project with <code>cargo new</code> we need to add a depencency on Actix to our
                <code>cargo.toml</code> file:
            </p>

            <figure class="highlight"><pre><code class="language-toml" data-lang="toml"><span class="nn">[dependencies]</span>
<span class="py">actix-web</span> <span class="p">=</span> <span class="s">"3"</span></code></pre></figure>


            <p>
                Then we need to replace the code in <code>main.rs</code> with a function to handle our
                sample endpoint, and appropriate config to run the Actix <code>HttpServer</code>:
            </p>


<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="nn">actix_web</span><span class="p">::{</span><span class="n">web</span><span class="p">,</span> <span class="n">App</span><span class="p">,</span> <span class="n">HttpResponse</span><span class="p">,</span> <span class="n">HttpServer</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">hello_world</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">HttpResponse</span> <span class="p">{</span>
    <span class="nn">HttpResponse</span><span class="p">::</span><span class="nf">Ok</span><span class="p">()</span><span class="nf">.body</span><span class="p">(</span><span class="s">"hi! üëã"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nd">#[actix_web::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">HttpServer</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="nn">App</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span><span class="nf">.route</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="nn">web</span><span class="p">::</span><span class="nf">get</span><span class="p">()</span><span class="nf">.to</span><span class="p">(</span><span class="n">hello_world</span><span class="p">)))</span>
        <span class="nf">.bind</span><span class="p">(</span><span class="s">"0.0.0.0:8000"</span><span class="p">)</span><span class="o">?</span>
        <span class="nf">.run</span><span class="p">()</span>
        <span class="k">.await</span>
<span class="p">}</span></code></pre></figure>

            <p>
                The <code>hello_world()</code> function returns a <code>200 OK</code>
                http response with a simple text message in the body.
            </p>
            <p>
                The <code>main()</code> function runs a new http server on port 8000,
                and binds the <code>hello_world()</code> function to the path <code>/hello</code>.
            </p>
            <p>
                We can quickly test this by running the server using <code>cargo run</code> and
                making a request locally:
            </p>

            <figure class="highlight"><pre><code class="language-http" data-lang="http"><span class="nn">GET http://localhost:8000/hello</span></code></pre></figure>


            <figure class="highlight"><pre><code class="language-http" data-lang="http"><span class="nn">hi! üëã
// GET http://localhost:8000/hello
// HTTP/1.1 200 OK
// content-length: 8</span></code></pre></figure>

            <h3>POSTing Data üì¨</h3>
            <p>
                Just returning static data isn't very useful - we need to be able to receive data from a client and then do something with it. To do that, we'll make a POST endpoint that can deserialize JSON into a type that we'll define.
            </p>
            <p>
                The data we receive should be identifiable, so it will have an <code>id</code> property that we will use a <code>Uuid</code> for, as well as some other data that we can store in <code>String</code>s:
            </p>


            <figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">SampleData</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="n">Uuid</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">special_code</span><span class="p">:</span> <span class="nb">String</span>
<span class="p">}</span></code></pre></figure>

            <p>
                In order to use <code>Uuid</code> we need to add a dependency on the <a href="https://crates.io/crates/uuid">uuid crate</a>. We also need to make this type (de)serializable and <a href="https://serde.rs/">Serde</a> seems to be the standard choice for that in Rust. Both should be added to the <code>cargo.toml</code> file as dependencies alongside <code>actix-web</code>:
            </p>

            <figure class="highlight"><pre><code class="language-toml" data-lang="toml"><span class="nn">[dependencies]</span>
<span class="nn">uuid</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.8"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="nn">["serde"]</span> <span class="p">}</span>
<span class="py">serde</span> <span class="p">=</span> <span class="s">"1.0.126"</span></code></pre></figure>

            <p>
                Cargo dependencies have a neat option to have different features toggled on or off when they're included in the <code>cargo.toml</code> file - here we make use of it to toggle on the serde bindings that are provided by the Uuid crate üòç
            </p>
            <p>
                With the dependencies in place, we can automatically derive the traits needed for serialization of our type:
            </p>


<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="nn">serde</span><span class="p">::{</span><span class="n">Deserialize</span><span class="p">,</span> <span class="n">Serialize</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">uuid</span><span class="p">::</span><span class="n">Uuid</span><span class="p">;</span>

<span class="nd">#[derive(Serialize,</span> <span class="nd">Deserialize,</span> <span class="nd">Debug,</span> <span class="nd">Clone)]</span>
<span class="nd">#[serde(rename_all</span> <span class="nd">=</span> <span class="s">"camelCase"</span><span class="nd">)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">SampleData</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="n">Uuid</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">special_code</span><span class="p">:</span> <span class="nb">String</span>
<span class="p">}</span></code></pre></figure>

<p>The extra <code>serde</code> attribute handles translating property names between <code>snake_case</code> in our rust code and <code>camelCase</code> which is more common in JSON.</p>

<p>With the data type in place, we can add an endpoint to the application that will receive this data as JSON. Actix uses <a href="https://actix.rs/docs/extractors/">Extractors</a> to handle deserialization automatically using the serde traits that we have already derived for our type. If deserialization fails, it will return a <code>400 Bad Request</code>, otherwise it will pass the deserialized value to our handler function. That makes it very straightforward for us to add an endpoint that receives the data and returns the id for it as a small check that everything is working as we expect.</p>

<p>The handler function is defined:</p>


<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">receive_data</span><span class="p">(</span><span class="n">sample</span><span class="p">:</span> <span class="nn">web</span><span class="p">::</span><span class="n">Json</span><span class="o">&lt;</span><span class="n">SampleData</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HttpResponse</span> <span class="p">{</span>
    <span class="nn">HttpResponse</span><span class="p">::</span><span class="nf">Ok</span><span class="p">()</span><span class="nf">.body</span><span class="p">(</span><span class="n">sample</span><span class="py">.id</span><span class="nf">.to_hyphenated</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">())</span>
<span class="p">}</span></code></pre></figure>

<p>And then added to the <code>HttpServer</code> in the <code>main</code> function:</p>


<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[actix_web::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">HttpServer</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="nn">App</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
            <span class="nf">.route</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="nn">web</span><span class="p">::</span><span class="nf">get</span><span class="p">()</span><span class="nf">.to</span><span class="p">(</span><span class="n">hello_world</span><span class="p">))</span>
            <span class="nf">.route</span><span class="p">(</span><span class="s">"data"</span><span class="p">,</span> <span class="nn">web</span><span class="p">::</span><span class="nf">post</span><span class="p">()</span><span class="nf">.to</span><span class="p">(</span><span class="n">receive_data</span><span class="p">))</span>
    <span class="p">})</span>
    <span class="nf">.bind</span><span class="p">(</span><span class="s">"0.0.0.0:8000"</span><span class="p">)</span><span class="o">?</span>
    <span class="nf">.run</span><span class="p">()</span>
    <span class="k">.await</span>
<span class="p">}</span></code></pre></figure>

<p>This is also quick to test using <code>cargo run</code> and making a request against the service:</p>


<figure class="highlight"><pre><code class="language-http" data-lang="http"><span class="nn">POST http://localhost:8000/data
Content-Type: application/json

{
  "id": "82115a42-3b60-4adf-b7c8-6a5afe73bc58",
  "name": "test",
  "specialCode": "1234"
}</span></code></pre></figure>


<figure class="highlight"><pre><code class="language-http" data-lang="http"><span class="nn">82115a42-3b60-4adf-b7c8-6a5afe73bc58
// POST http://localhost:8000/data
// HTTP/1.1 200 OK
// content-length: 36</span></code></pre></figure>

<h3>Logging ü™µ</h3>

<p>
    When the service is deployed and being used, it would be useful to have it log some information so we could monitor if everything was running as expected. We can start very simply by printing messages when the service starts and stops so we get some output to tell us that it's running:
</p>


<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[actix_web::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"üßë‚Äçüî¨ Sample Service Starting"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">HttpServer</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="nn">App</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
            <span class="nf">.route</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="nn">web</span><span class="p">::</span><span class="nf">get</span><span class="p">()</span><span class="nf">.to</span><span class="p">(</span><span class="n">hello_world</span><span class="p">))</span>
            <span class="nf">.route</span><span class="p">(</span><span class="s">"data"</span><span class="p">,</span> <span class="nn">web</span><span class="p">::</span><span class="nf">post</span><span class="p">()</span><span class="nf">.to</span><span class="p">(</span><span class="n">receive_data</span><span class="p">))</span>
    <span class="p">})</span>
    <span class="nf">.bind</span><span class="p">(</span><span class="s">"0.0.0.0:8000"</span><span class="p">)</span><span class="o">?</span>
    <span class="nf">.run</span><span class="p">()</span>
    <span class="k">.await</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"üßë‚Äçüî¨ Sample Service Stopping"</span><span class="p">);</span>

    <span class="n">result</span>
<span class="p">}</span></code></pre></figure>

<p>Note how we now assign the result of running the <code>HttpServer</code> to a value so that we can print a message just before the service terminates.</p>
<p>This gives us an idea that the service started (or stopped), but it doesn't provide any information about what happens while the service is running - fortunately we can provide Actix with a <code>Logger</code> and it will log information about each request. Actix uses <a href="https://actix.rs/docs/middleware/">Middleware</a> to implement logging, and we can pass it any log implementation that is compatible with the <a href="https://docs.rs/log/0.4.14/log/">log crate</a> facade. There are <a href="https://docs.rs/env_logger/0.9.0/env_logger/">sensible</a> <a href="https://docs.rs/pretty_env_logger/0.4.0/pretty_env_logger/">logging</a> <a href="https://docs.rs/log4rs/1.0.0/log4rs/">options</a> to choose from, but for this service we'll use the much more interesting <a href="https://crates.io/crates/emoji-logger">emoji-logger</a> üòÄ</p>

<p>To set up the logger we first add a dependency in <code>cargo.toml</code>:</p>


<figure class="highlight"><pre><code class="language-toml" data-lang="toml"><span class="nn">[dependencies]</span>
<span class="py">emoji-logger</span> <span class="p">=</span> <span class="s">"0.1.0"</span></code></pre></figure>

<p>Reference the crate with <code>extern crate emoji_logger;</code> at the top of <code>main.rs</code> and then initialise it in the <code>main()</code> function using <code>emoji_logger::init();</code>. This will create the logger, but we still need to configure Actix to use it by passing one or more Loggers with the format we want. We can also provide an environment variable to configure the level of log messages that are output - for now we can set that in code, but later we should read that from the environment so that it's easy to configure between different environments (for example, we might want to output a lot of data when running locally, but find that would be too spammy when the service is running in production).</p>

<p>With our logger initialised and configured with Actix we now have the following code:</p>


<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="nn">actix_web</span><span class="p">::{</span><span class="n">App</span><span class="p">,</span> <span class="n">HttpResponse</span><span class="p">,</span> <span class="n">HttpServer</span><span class="p">,</span> <span class="nn">middleware</span><span class="p">::</span><span class="n">Logger</span><span class="p">,</span> <span class="n">web</span><span class="p">};</span>

<span class="k">extern</span> <span class="n">crate</span> <span class="n">emoji_logger</span><span class="p">;</span>

<span class="nd">#[actix_web::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"üßë‚Äçüî¨ Sample Service Starting"</span><span class="p">);</span>

    <span class="nn">std</span><span class="p">::</span><span class="nn">env</span><span class="p">::</span><span class="nf">set_var</span><span class="p">(</span><span class="s">"RUST_LOG"</span><span class="p">,</span> <span class="s">"actix_web=info"</span><span class="p">);</span>
    <span class="nn">emoji_logger</span><span class="p">::</span><span class="nf">init</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">HttpServer</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="nn">App</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
            <span class="nf">.wrap</span><span class="p">(</span><span class="nn">Logger</span><span class="p">::</span><span class="nf">default</span><span class="p">())</span>
            <span class="nf">.route</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="nn">web</span><span class="p">::</span><span class="nf">get</span><span class="p">()</span><span class="nf">.to</span><span class="p">(</span><span class="n">hello_world</span><span class="p">))</span>
            <span class="nf">.route</span><span class="p">(</span><span class="s">"data"</span><span class="p">,</span> <span class="nn">web</span><span class="p">::</span><span class="nf">post</span><span class="p">()</span><span class="nf">.to</span><span class="p">(</span><span class="n">receive_data</span><span class="p">))</span>
    <span class="p">})</span>
    <span class="nf">.bind</span><span class="p">(</span><span class="s">"0.0.0.0:8000"</span><span class="p">)</span><span class="o">?</span>
    <span class="nf">.run</span><span class="p">()</span>
    <span class="k">.await</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"üßë‚Äçüî¨ Sample Service Stopping"</span><span class="p">);</span>

    <span class="n">result</span>
<span class="p">}</span></code></pre></figure>

<p>We can double check this by running the service with <code>cargo run</code>, making some sample HTTP requests against it, and then checking the console output - it should show something like this:</p>

<figure class="highlight"><pre><code><span class="nn">üßë‚Äçüî¨ Sample Service Starting
üòã I  27.44  actix_web:logger > 127.0.0.1:61222 "GET /hello HTTP/1.1" 200 8 "-" "-" 0.000167
üòã I  95.19  actix_web:logger > 127.0.0.1:61416 "POST /data HTTP/1.1" 200 36 "-" "-" 0.000248
üòã I  125.96  actix_web:logger > 127.0.0.1:61506 "POST /data HTTP/1.1" 400 0 "-" "-" 0.000240
^Cüßë‚Äçüî¨ Sample Service Stopping</span></code></pre></figure>

<p>Actix supports a bunch of different <a href="https://actix.rs/docs/middleware/#format">format options</a> to configure what should be included in log messages if we wanted to change the output, but the default is good enough for now.</p>

        </section>

        <section class="database">
            <h2>Saving Data In Postgres</h2>

            <h3>Config üóí</h3>

            <p>Now that our service can receive data, we need to do something with it - and we can start by saving it to a database.</p>
            <p>There are many ways to setup a database server that won't be covered here, but as a prerequisite for our code we will need a table to work against:</p>


            <figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="k">public</span><span class="p">.</span><span class="n">sample</span> <span class="p">(</span>
  <span class="n">id</span> <span class="n">uuid</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">sample_data</span> <span class="n">jsonb</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">CONSTRAINT</span> <span class="n">sample_pk</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">);</span></code></pre></figure>

            <p>For providing connection details to our service it's best if we can use an external configuration source so that we can change the values without having to recompile and deploy. We can use environment variables for this purpose, and use the <a href="https://crates.io/crates/dotenv">rust-dotenv</a> crate to keep configuration values for local development in a config file.</p>

            <p>To do this we add <code>dotenv</code> to our dependencies:</p>

            <figure class="highlight"><pre><code class="language-toml" data-lang="toml"><span class="nn">[dependencies]</span>
<span class="py">dotenv</span> <span class="p">=</span> <span class="s">"0.15.0"</span></code></pre></figure>

            <p>Add a <code>.env</code> file in the same directory as <code>cargo.toml</code> containing the configuration values we want to use:</p>

            <figure class="highlight"><pre><code><span class="nn">PG.USER=dbuser
PG.PASSWORD=secret-database-password
PG.HOST=127.0.0.1
PG.PORT=5432
PG.DBNAME=sampledb
PG.POOL.MAX_SIZE=16

RUST_LOG=actix_web=info</span></code></pre></figure>

            <p>Then reference <code>dotenv</code> in our code and load the values in our <code>main()</code> function:</p>


            <figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="nn">dotenv</span><span class="p">::</span><span class="n">dotenv</span><span class="p">;</span>

<span class="nd">#[actix_web::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="c">// this loads our .env file and includes the values in std::env</span>
<span class="nf">dotenv</span><span class="p">()</span><span class="nf">.ok</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure>

            <p>With the values defined and loaded from the environment, they can be moved into a <code>Config</code> object that will let us create a connection pool for the database that can be passed to Actix to provide to handlers when needed. There are several dependencies needed to communicate with the database:</p>

            <figure class="highlight"><pre><code class="language-toml" data-lang="toml"><span class="nn">[dependencies]</span>
<span class="py">deadpool-postgres</span> <span class="p">=</span> <span class="s">"0.5.0"</span>
<span class="nn">tokio-postgres</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span><span class="p">=</span><span class="s">"0.5.1"</span><span class="p">,</span> <span class="py">features</span><span class="p">=[</span><span class="s">"with-uuid-0_8"</span><span class="p">,</span> <span class="s">"with-serde_json-1"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">postgres-openssl</span> <span class="p">=</span> <span class="s">"0.3.0"</span>
<span class="py">openssl</span> <span class="p">=</span> <span class="s">"0.10.35"</span>
<span class="py">config</span> <span class="p">=</span> <span class="s">"0.11.0"</span></code></pre></figure>

            <p class="warning">‚ö† For <code>deadpool-postgres</code> it's important (currently) to use this version because <code>actix-web</code> and <code>deadpool-postgres</code> reference different, incompatible versions of tokio in their latest versions.</p>

            <p>This also enables support in <code>tokio-postgres</code> for using <code>Uuid</code> values, and using serde to handle serialization of JSON values by toggling those features on.</p>

            <p>A <code>DbConfig</code> type can give us a straightforward wrapper around the <code>deadpool_postgres::Config</code> type and allow us to encapsulate loading configuration values into it:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="p">::</span><span class="nn">config</span><span class="p">::</span><span class="n">ConfigError</span><span class="p">;</span>

<span class="nd">#[derive(Deserialize)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">DbConfig</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">pg</span><span class="p">:</span> <span class="nn">deadpool_postgres</span><span class="p">::</span><span class="n">Config</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">DbConfig</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_env</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span> <span class="n">ConfigError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cfg</span> <span class="o">=</span> <span class="p">::</span><span class="nn">config</span><span class="p">::</span><span class="nn">Config</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">cfg</span><span class="nf">.merge</span><span class="p">(::</span><span class="nn">config</span><span class="p">::</span><span class="nn">Environment</span><span class="p">::</span><span class="nf">new</span><span class="p">())</span><span class="o">?</span><span class="p">;</span>
        <span class="n">cfg</span><span class="nf">.try_into</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>


<p>We can then use this in a factory function to create a connection pool that we can pass to Actix so that it in turn can pass it on to handlers that need to access the database.</p>


<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="nn">deadpool_postgres</span><span class="p">::</span><span class="n">Pool</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">openssl</span><span class="p">::</span><span class="nn">ssl</span><span class="p">::{</span><span class="n">SslConnector</span><span class="p">,</span> <span class="n">SslMethod</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">postgres_openssl</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">make_db_pool</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Pool</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">config</span> <span class="o">=</span> <span class="nn">DbConfig</span><span class="p">::</span><span class="nf">from_env</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">builder</span> <span class="o">=</span> <span class="nn">SslConnector</span><span class="p">::</span><span class="nf">builder</span><span class="p">(</span><span class="nn">SslMethod</span><span class="p">::</span><span class="nf">tls</span><span class="p">())</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">connector</span> <span class="o">=</span> <span class="nn">MakeTlsConnector</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">builder</span><span class="nf">.build</span><span class="p">());</span>
    <span class="n">config</span><span class="py">.pg</span><span class="nf">.create_pool</span><span class="p">(</span><span class="n">connector</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure>

<p>This function uses <code>unwrap()</code> instead of returning a <code>Result</code> with any potential error because it will be run only once, on startup, and any errors would be configuration errors that should be corrected before running the service. Additionally, <code>deadpool</code> won't try to establish a connection until one is needed, which should rule out transient database connectivity errors preventing the service from starting - so panicking is (imo) appropriate üòÖ</p>

<p>Using the <code>data()</code> method when setting up the <code>HttpServer</code> will allow Actix to give handlers access to the connection pool:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[actix_web::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"üßë‚Äçüî¨ Sample Service Starting"</span><span class="p">);</span>

    <span class="nf">dotenv</span><span class="p">()</span><span class="nf">.ok</span><span class="p">();</span>
    <span class="nn">emoji_logger</span><span class="p">::</span><span class="nf">init</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">pool</span> <span class="o">=</span> <span class="nf">make_db_pool</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">HttpServer</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="nn">App</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
            <span class="nf">.wrap</span><span class="p">(</span><span class="nn">Logger</span><span class="p">::</span><span class="nf">default</span><span class="p">())</span>
            <span class="nf">.data</span><span class="p">(</span><span class="n">pool</span><span class="nf">.clone</span><span class="p">())</span>
            <span class="nf">.route</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="nn">web</span><span class="p">::</span><span class="nf">get</span><span class="p">()</span><span class="nf">.to</span><span class="p">(</span><span class="n">hello_world</span><span class="p">))</span>
            <span class="nf">.route</span><span class="p">(</span><span class="s">"data"</span><span class="p">,</span> <span class="nn">web</span><span class="p">::</span><span class="nf">post</span><span class="p">()</span><span class="nf">.to</span><span class="p">(</span><span class="n">receive_data</span><span class="p">))</span>
    <span class="p">})</span>
    <span class="nf">.bind</span><span class="p">(</span><span class="s">"0.0.0.0:8000"</span><span class="p">)</span><span class="o">?</span>
    <span class="nf">.run</span><span class="p">()</span>
    <span class="k">.await</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"üßë‚Äçüî¨ Sample Service Stopping"</span><span class="p">);</span>

    <span class="n">result</span>
<span class="p">}</span></code></pre></figure>

<h3>Saving Data üíæ</h3>

<p>Now that we have a way to access the database, we should save any data that we receive to it.</p>
<p>We use a <code>deadpool_postgres::Client</code> to communicate with the database through the connection pool and will need some <code>SampleData</code> to insert into it:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="nn">deadpool_postgres</span><span class="p">::{</span><span class="n">Client</span><span class="p">,</span> <span class="n">Pool</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">tokio_postgres</span><span class="p">::</span><span class="nn">types</span><span class="p">::</span><span class="n">Json</span><span class="p">;</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">insert_sample</span><span class="p">(</span><span class="n">client</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Client</span><span class="p">,</span> <span class="n">sample</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">SampleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="nb">u64</span><span class="p">,</span> <span class="nn">tokio_postgres</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">client</span>
        <span class="nf">.execute</span><span class="p">(</span>
            <span class="s">"INSERT INTO public.sample (id, sample_data) VALUES ($1, $2)"</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="n">sample</span><span class="py">.id</span><span class="p">,</span> <span class="o">&amp;</span><span class="nf">Json</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sample</span><span class="p">)],</span>
        <span class="p">)</span>
        <span class="k">.await</span>
<span class="p">}</span></code></pre></figure>

<p>The <code>Data<></code> extractor from Actix allows us to get access to application state, which in this case is the connection pool we created earlier. The <code>Pool</code> in turn allows us to get a <code>Client</code> to communicate with the database:</p>


<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">async</span> <span class="k">fn</span> <span class="nf">receive_data</span><span class="p">(</span><span class="n">sample</span><span class="p">:</span> <span class="nn">web</span><span class="p">::</span><span class="n">Json</span><span class="o">&lt;</span><span class="n">SampleData</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">db_pool</span><span class="p">:</span> <span class="nn">web</span><span class="p">::</span><span class="n">Data</span><span class="o">&lt;</span><span class="n">Pool</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HttpResponse</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">client</span><span class="p">:</span> <span class="n">Client</span> <span class="o">=</span> <span class="n">db_pool</span><span class="nf">.get</span><span class="p">()</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="nf">insert_sample</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">)</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="nn">HttpResponse</span><span class="p">::</span><span class="nf">Ok</span><span class="p">()</span><span class="nf">.body</span><span class="p">(</span><span class="n">sample</span><span class="py">.id</span><span class="nf">.to_hyphenated</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">())</span>
<span class="p">}</span></code></pre></figure>

<p>We don't need to adjust the server configuration to accommodate any of the changes we've made to the handler here, and this can be tested by running the service with <code>cargo run</code> and then querying the database after making a successful POST request.</p>


<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">sampledb</span><span class="o">=</span><span class="c"># select * from sample;</span>
    <span class="nb">id</span>                  |                                      sample_data                                      
    <span class="nt">--------------------------------------</span>+---------------------------------------------------------------------------------------
 9a6743c2-7c49-4c4d-a136-14714ba50247 | <span class="o">{</span><span class="s2">"id"</span>: <span class="s2">"9a6743c2-7c49-4c4d-a136-14714ba50247"</span>, <span class="s2">"name"</span>: <span class="s2">"name"</span>, <span class="s2">"specialCode"</span>: <span class="s2">"code"</span><span class="o">}</span>
    <span class="o">(</span>1 row<span class="o">)</span></code></pre></figure>

<h3>Handling Errors ‚ùå</h3>

<p>The <code>receive_data</code> function works properly for the happy path of events, but if there are any problems connecting to the database or inserting a new record, it will panic. Actix will catch the panic for us and return a <code>500 Internal Server Error</code> to the client, but that doesn't provide a very good experience and panicking for every error like that is very bad practice.</p>

<p>To improve things, we can create a custom error type that implements the <code>ResponseError</code> trait and have the handler return a <code>Result</code> then Actix will be able to return a better response to the client.</p>

<p>The error type will also need to implement some other traits, but by taking a dependency on the <a href="https://crates.io/crates/derive_more">derive_more</a> crate, these can be generated.</p>

<figure class="highlight"><pre><code class="language-toml" data-lang="toml"><span class="nn">[dependencies]</span>
<span class="py">derive_more</span> <span class="p">=</span> <span class="s">"0.99.16"</span></code></pre></figure>

<p>With that in place we can define an error type that fits the few errors we want to handle:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="nn">actix_web</span><span class="p">::{</span><span class="nn">middleware</span><span class="p">::</span><span class="n">Logger</span><span class="p">,</span> <span class="n">web</span><span class="p">,</span> <span class="n">App</span><span class="p">,</span> <span class="n">HttpResponse</span><span class="p">,</span> <span class="n">HttpServer</span><span class="p">,</span> <span class="n">ResponseError</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">derive_more</span><span class="p">::{</span><span class="n">Display</span><span class="p">,</span> <span class="n">From</span><span class="p">};</span>

<span class="nd">#[derive(Display,</span> <span class="nd">From,</span> <span class="nd">Debug)]</span>
<span class="k">enum</span> <span class="n">SampleError</span> <span class="p">{</span>
    <span class="n">DatabaseError</span><span class="p">,</span>
    <span class="n">InvalidData</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span> <span class="k">for</span> <span class="n">SampleError</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">ResponseError</span> <span class="k">for</span> <span class="n">SampleError</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">error_response</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HttpResponse</span> <span class="p">{</span>
        <span class="k">match</span> <span class="o">*</span><span class="k">self</span> <span class="p">{</span>
            <span class="nn">SampleError</span><span class="p">::</span><span class="n">DatabaseError</span> <span class="k">=&gt;</span> <span class="nn">HttpResponse</span><span class="p">::</span><span class="nf">InternalServerError</span><span class="p">()</span><span class="nf">.finish</span><span class="p">(),</span>
            <span class="nn">SampleError</span><span class="p">::</span><span class="n">InvalidData</span> <span class="k">=&gt;</span> <span class="nn">HttpResponse</span><span class="p">::</span><span class="nf">BadRequest</span><span class="p">()</span><span class="nf">.finish</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The error types are kept as cases in an <code>enum</code> and we match over them to provide a different <code>HttpResponse</code> that Actix will return to clients if our handler returns a failing result. The responses implemented here are very simple, but if needed, we could also add more data to the response to help clients understand the problem.</p>

<p>In the handler, the calls to <code>unwrap()</code> can now be replaced with <code>map_err</code> calls to convert the error received from database code into the new <code>ResponseError</code> type then we can use the <code>?</code> operator to return the failure immediately:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">async</span> <span class="k">fn</span> <span class="nf">receive_data</span><span class="p">(</span>
    <span class="n">sample</span><span class="p">:</span> <span class="nn">web</span><span class="p">::</span><span class="n">Json</span><span class="o">&lt;</span><span class="n">SampleData</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">db_pool</span><span class="p">:</span> <span class="nn">web</span><span class="p">::</span><span class="n">Data</span><span class="o">&lt;</span><span class="n">Pool</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">HttpResponse</span><span class="p">,</span> <span class="n">SampleError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">client</span><span class="p">:</span> <span class="n">Client</span> <span class="o">=</span> <span class="n">db_pool</span>
        <span class="nf">.get</span><span class="p">()</span>
        <span class="k">.await</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="mi">_</span><span class="p">|</span> <span class="nn">SampleError</span><span class="p">::</span><span class="n">DatabaseError</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">insert_sample</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">)</span>
        <span class="k">.await</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="mi">_</span><span class="p">|</span> <span class="nn">SampleError</span><span class="p">::</span><span class="n">InvalidData</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="nn">HttpResponse</span><span class="p">::</span><span class="nf">Ok</span><span class="p">()</span><span class="nf">.body</span><span class="p">(</span><span class="n">sample</span><span class="py">.id</span><span class="nf">.to_hyphenated</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()))</span>
<span class="p">}</span></code></pre></figure>

<p>Changing the return type to <code>Result</code> also requires wrapping the return value in <code>Ok()</code> so that the types line up properly.</p>

<p>The main difference from the outside is that now submitting two requests with the same id will return a <code>400 Bad Request</code> instead of panicking and returning <code>500 Internal Server Error</code>.</p>
        </section>

        <section class="kafka">
            <h2>Sending Messages Over Kafka</h2>
            <h3>Config üóí</h3>
            <p>The final requirement for the service is that it can raise events about new sample data over Kafka, which will be done using a <code>FutureProducer</code> from <a href="https://github.com/fede1024/rust-rdkafka">rust-rdkafka</a>.</p>
            <p>When connecting to a local Kafka instance we typically wouldn't need any client authentication, however when connecting to a production Kafka cluster we probably need to use more secure methods; in this case we need to use SASL to connect. As long as we include the necessary dependencies for both approaches, we can vary the <a href="https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md">configuration options</a> that we pass in to ensure that we use the proper method in each environment.</p>

            <p>In <code>cargo.toml</code> we add these dependencies:</p>

            <figure class="highlight"><pre><code class="language-toml" data-lang="toml"><span class="nn">[dependencies]</span>
<span class="nn">rdkafka</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.26.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span> <span class="s">"ssl"</span><span class="p">,</span> <span class="s">"sasl"</span><span class="p">]</span> <span class="p">}</span>
<span class="nn">sasl2-sys</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"*"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span> <span class="s">"vendored"</span> <span class="p">]</span> <span class="p">}</span></code></pre></figure>

            <p>The <code>rdkafka</code> dependency should have <code>ssl</code> and <code>sasl</code> features toggled on, and the <code>sasl2-sys</code> dependency is included using <code>*</code> as the version so that it will just take whichever version <code>rdkafka</code> uses, toggling on the vendored feature ensuring that <code>libsasl2</code> will be bundled with the service rather than relying on the underlying system to already have this library.</p>

            <p>We want to load our configuration from the environment, but the properties included in the configuration might also vary between environments. For example, locally we might only need to set <code>bootstrap.servers</code> but in production we would rely on setting <code>security.protocol</code> and the properties pertaining to our chosen authentication method. A simple way of ensuring that we load all the configuration values for each environment without having to model or handle missing values is to add a prefix to their names in the environment and iterate over them adding them directly to the <code>rdkafka::ClientConfig</code>. With that approach we can define a function to create a producer:</p>


<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="nn">rdkafka</span><span class="p">::{</span><span class="nn">producer</span><span class="p">::</span><span class="n">FutureProducer</span><span class="p">,</span> <span class="n">ClientConfig</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">make_producer</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">FutureProducer</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">config</span> <span class="o">=</span> <span class="nn">ClientConfig</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">env</span><span class="p">::</span><span class="nf">vars</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(|(</span><span class="n">key</span><span class="p">,</span> <span class="mi">_</span><span class="p">)|</span> <span class="n">key</span><span class="nf">.starts_with</span><span class="p">(</span><span class="s">"KAFKA_"</span><span class="p">))</span>
        <span class="nf">.for_each</span><span class="p">(|(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="n">key</span><span class="nf">.trim_start_matches</span><span class="p">(</span><span class="s">"KAFKA_"</span><span class="p">)</span><span class="nf">.to_lowercase</span><span class="p">();</span>

            <span class="n">config</span><span class="nf">.set</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
        <span class="p">});</span>

    <span class="n">config</span>
        <span class="nf">.set</span><span class="p">(</span><span class="s">"message.timeout.ms"</span><span class="p">,</span> <span class="s">"5000"</span><span class="p">)</span>
        <span class="py">.create</span><span class="p">::</span><span class="o">&lt;</span><span class="n">FutureProducer</span><span class="o">&gt;</span><span class="p">()</span>
        <span class="nf">.expect</span><span class="p">(</span><span class="s">"Producer creation error"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>This function can also set any config values that we don't want to vary across environments (this sets <code>message.timeout.ms</code> directly), and will panic if it can't create a producer because we expect that to be caused by a configuration error that we would want to correct before running the service.</p>

<p>With the appropriate config value in our .env file:</p>

<figure class="highlight"><pre><code><span class="nn">KAFKA_BOOTSTRAP.SERVERS=localhost:29092
</span></code></pre></figure>

<p>The main function can be modified to create a <code>FutureProducer</code> on startup that can be used by our handlers:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[actix_web::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"üßë‚Äçüî¨ Sample Service Starting"</span><span class="p">);</span>

    <span class="nf">dotenv</span><span class="p">()</span><span class="nf">.ok</span><span class="p">();</span>
    <span class="nn">emoji_logger</span><span class="p">::</span><span class="nf">init</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">pool</span> <span class="o">=</span> <span class="nf">make_db_pool</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">producer</span> <span class="o">=</span> <span class="nf">make_producer</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">HttpServer</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="nn">App</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
            <span class="nf">.wrap</span><span class="p">(</span><span class="nn">Logger</span><span class="p">::</span><span class="nf">default</span><span class="p">())</span>
            <span class="nf">.data</span><span class="p">(</span><span class="n">pool</span><span class="nf">.clone</span><span class="p">())</span>
            <span class="nf">.data</span><span class="p">(</span><span class="n">producer</span><span class="nf">.clone</span><span class="p">())</span>
            <span class="nf">.route</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="nn">web</span><span class="p">::</span><span class="nf">get</span><span class="p">()</span><span class="nf">.to</span><span class="p">(</span><span class="n">hello_world</span><span class="p">))</span>
            <span class="nf">.route</span><span class="p">(</span><span class="s">"data"</span><span class="p">,</span> <span class="nn">web</span><span class="p">::</span><span class="nf">post</span><span class="p">()</span><span class="nf">.to</span><span class="p">(</span><span class="n">receive_data</span><span class="p">))</span>
    <span class="p">})</span>
    <span class="nf">.bind</span><span class="p">(</span><span class="s">"0.0.0.0:8000"</span><span class="p">)</span><span class="o">?</span>
    <span class="nf">.run</span><span class="p">()</span>
    <span class="k">.await</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"üßë‚Äçüî¨ Sample Service Stopping"</span><span class="p">);</span>

    <span class="n">result</span>
<span class="p">}</span></code></pre></figure>

<p>This uses the same data method as for the database connection pool to include the <code>FutureProducer</code> as part of application state in Actix.</p>

<h3>Sending Messages üì®</h3>
<p>With the connection in place, we need to actually produce messages to send over Kafka. We'll send messages as JSON, and will wrap them in a standard envelope to make handling a variety of messages easier for a consumer.</p>
<p><code>serde_json</code> has a handy <a href="https://docs.serde.rs/serde_json/macro.json.html"><code>json!</code> macro</a> that can take a JSON literal and return a <code>Value</code>, and we can use this to wrap the data to be sent in our envelope format. The envelope format contains a message type that will always be the same as we only send one type of message, and a <code>messageId</code> field that we will set using a new <code>Uuid</code> To do this requires adding a dependency on <code>serde_json</code> and adding an extra feature to the <code>uuid</code> dependency:</p>

<figure class="highlight"><pre><code class="language-toml" data-lang="toml"><span class="nn">[dependencies]</span>
<span class="nn">uuid</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.8"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"serde"</span><span class="p">,</span> <span class="s">"v4"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">serde_json</span> <span class="p">=</span> <span class="s">"1.0"</span></code></pre></figure>

<p>With those in place we can define a function that can take a <code>FutureProducer</code> and some <code>SampleData</code> then wrap the data in the envelope format and send it to Kafka with the producer:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="nn">serde_json</span><span class="p">::</span><span class="n">json</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">Duration</span><span class="p">;</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">send_sample_message</span><span class="p">(</span>
    <span class="n">producer</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">FutureProducer</span><span class="p">,</span>
    <span class="n">sample</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">SampleData</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="nd">json!</span><span class="p">({</span>
        <span class="s">"messageId"</span> <span class="p">:</span> <span class="nn">Uuid</span><span class="p">::</span><span class="nf">new_v4</span><span class="p">(),</span>
        <span class="s">"type"</span> <span class="p">:</span> <span class="s">"sample_received"</span><span class="p">,</span>
        <span class="s">"data"</span> <span class="p">:</span> <span class="n">sample</span>
    <span class="p">});</span>

    <span class="n">producer</span>
        <span class="nf">.send</span><span class="p">(</span>
            <span class="nn">FutureRecord</span><span class="p">::</span><span class="nf">to</span><span class="p">(</span><span class="s">"sample-received"</span><span class="p">)</span>
                <span class="nf">.key</span><span class="p">(</span><span class="s">"messageId"</span><span class="p">)</span>
                <span class="nf">.payload</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="nf">.to_string</span><span class="p">()),</span>
            <span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">.await</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="mi">_</span><span class="p">|</span> <span class="p">())</span>
        <span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure>

<p>This creates a <code>FutureRecord</code> to pass the message to the <code>sample-received</code> topic on Kafka, and provides a <code>Duration</code> to the <code>producer.send</code> method to specify how long it should wait if the queue is full when trying to send the message - setting this to <code>0</code> will mean that it will fail immediately if the message cannot be enqueued.</p>

<p>In the case that this message does fail to send, the <code>unwrap()</code> call will cause it to panic even though the Kafka library returns a result. We can add a new error case to the <code>SampleError</code> type so that we can handle the error properly and return a message to the client to explain what failed:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[derive(Display,</span> <span class="nd">From,</span> <span class="nd">Debug)]</span>
<span class="k">enum</span> <span class="n">SampleError</span> <span class="p">{</span>
    <span class="n">DatabaseError</span><span class="p">,</span>
    <span class="n">InvalidData</span><span class="p">,</span>
    <span class="n">KafkaError</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span> <span class="k">for</span> <span class="n">SampleError</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">ResponseError</span> <span class="k">for</span> <span class="n">SampleError</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">error_response</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HttpResponse</span> <span class="p">{</span>
        <span class="k">match</span> <span class="o">*</span><span class="k">self</span> <span class="p">{</span>
            <span class="nn">SampleError</span><span class="p">::</span><span class="n">DatabaseError</span> <span class="k">=&gt;</span> <span class="nn">HttpResponse</span><span class="p">::</span><span class="nf">InternalServerError</span><span class="p">()</span><span class="nf">.body</span><span class="p">(</span><span class="s">"Error saving to database"</span><span class="p">),</span>
            <span class="nn">SampleError</span><span class="p">::</span><span class="n">InvalidData</span> <span class="k">=&gt;</span> <span class="nn">HttpResponse</span><span class="p">::</span><span class="nf">BadRequest</span><span class="p">()</span><span class="nf">.finish</span><span class="p">(),</span>
            <span class="nn">SampleError</span><span class="p">::</span><span class="n">KafkaError</span> <span class="k">=&gt;</span> <span class="nn">HttpResponse</span><span class="p">::</span><span class="nf">InternalServerError</span><span class="p">()</span><span class="nf">.body</span><span class="p">(</span><span class="s">"Error sending to kafka"</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p class="information">‚Ñπ It's worth noting that the <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/error/enum.KafkaError.html"><code>KafkaError</code></a> returned from <code>rdkafka</code> provides a lot more detail about what went wrong when sending to Kafka, which could be useful to refine this message in the future - but we won't go into that here.</p>
<p>With the error type updated, the send function can be updated to return a <code>Result</code>:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">async</span> <span class="k">fn</span> <span class="nf">send_sample_message</span><span class="p">(</span>
    <span class="n">producer</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">FutureProducer</span><span class="p">,</span>
    <span class="n">sample</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">SampleData</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">SampleError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="nd">json!</span><span class="p">({</span>
        <span class="s">"messageId"</span> <span class="p">:</span> <span class="nn">Uuid</span><span class="p">::</span><span class="nf">new_v4</span><span class="p">(),</span>
        <span class="s">"type"</span> <span class="p">:</span> <span class="s">"sample_received"</span><span class="p">,</span>
        <span class="s">"data"</span> <span class="p">:</span> <span class="n">sample</span>
    <span class="p">});</span>

    <span class="n">producer</span>
        <span class="nf">.send</span><span class="p">(</span>
            <span class="nn">FutureRecord</span><span class="p">::</span><span class="nf">to</span><span class="p">(</span><span class="s">"sample-received"</span><span class="p">)</span>
                <span class="nf">.key</span><span class="p">(</span><span class="s">"messageId"</span><span class="p">)</span>
                <span class="nf">.payload</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="nf">.to_string</span><span class="p">()),</span>
            <span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">.await</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="mi">_</span><span class="p">|</span> <span class="nn">SampleError</span><span class="p">::</span><span class="n">KafkaError</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="mi">_</span><span class="p">|</span> <span class="p">())</span>
<span class="p">}</span></code></pre></figure>

<p>Then the <code>receive_data</code> handler can be updated to take a <code>FutureProducer</code> from application state, and send a sample message to Kafka after saving it to the database:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">async</span> <span class="k">fn</span> <span class="nf">receive_data</span><span class="p">(</span>
    <span class="n">sample</span><span class="p">:</span> <span class="nn">web</span><span class="p">::</span><span class="n">Json</span><span class="o">&lt;</span><span class="n">SampleData</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">db_pool</span><span class="p">:</span> <span class="nn">web</span><span class="p">::</span><span class="n">Data</span><span class="o">&lt;</span><span class="n">Pool</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">producer</span><span class="p">:</span> <span class="nn">web</span><span class="p">::</span><span class="n">Data</span><span class="o">&lt;</span><span class="n">FutureProducer</span><span class="o">&gt;</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">HttpResponse</span><span class="p">,</span> <span class="n">SampleError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">client</span><span class="p">:</span> <span class="n">Client</span> <span class="o">=</span> <span class="n">db_pool</span>
        <span class="nf">.get</span><span class="p">()</span>
        <span class="k">.await</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="mi">_</span><span class="p">|</span> <span class="nn">SampleError</span><span class="p">::</span><span class="n">DatabaseError</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">insert_sample</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">)</span>
        <span class="k">.await</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="mi">_</span><span class="p">|</span> <span class="nn">SampleError</span><span class="p">::</span><span class="n">InvalidData</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">send_sample_message</span><span class="p">(</span><span class="o">&amp;</span><span class="n">producer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="nn">HttpResponse</span><span class="p">::</span><span class="nf">Ok</span><span class="p">()</span><span class="nf">.body</span><span class="p">(</span><span class="n">sample</span><span class="py">.id</span><span class="nf">.to_hyphenated</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()))</span>
<span class="p">}</span></code></pre></figure>

<p>With all the pieces in place we can test manually by running with <code>cargo run</code>, making a http request to the endpoint and then consuming the Kafka topic directly (I'll use <a href="https://github.com/birdayz/kaf">Kaf</a> for this):</p>

<figure class="highlight"><pre><code class="language-http" data-lang="http"><span class="nn">POST http://localhost:8000/data
Content-Type: application/json

{
  "id" : "67a678eb-70b7-4c86-bf1d-94dd5d8bf39d",
  "name" : "Dave the Sample",
  "specialCode" : "code"
}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>kaf consume sample-received
Key:         messageId
Partition:   0
Offset:      0
Timestamp:   2021-07-23 09:43:48.44 +0200 CEST
<span class="o">{</span>
  <span class="s2">"data"</span>: <span class="o">{</span>
    <span class="s2">"id"</span>: <span class="s2">"67a678eb-70b7-4c86-bf1d-94dd5d8bf39d"</span>,
    <span class="s2">"name"</span>: <span class="s2">"Dave the Sample"</span>,
    <span class="s2">"specialCode"</span>: <span class="s2">"code"</span>
  <span class="o">}</span>,
  <span class="s2">"messageId"</span>: <span class="s2">"b92d6fe0-4354-4f5c-99f1-ca2547f2483a"</span>,
  <span class="s2">"type"</span>: <span class="s2">"sample_received"</span>
<span class="o">}</span></code></pre></figure>

<p>This shows that the message went to our topic in the format we expected üéâ</p>

        </section>
        <section class="conclusion" >
            <h2>Wrapping Up</h2>

            <p>With all this in place we should now have a service that can receive data over http and then send it to both a Postgres database and a Kafka topic. There are a bunch of potential improvements that could be made - for example, we might end up in a bad state where we write to the database successfully, but never send the value over Kafka, which might cause issues in downstream systems - but this should be needs-meeting for most cases. üôÇ</p>

            <p>Hopefully this is a useful guide for putting all these pieces together, and as I said at the start I'm not a Rust expert and this is mostly a walkthrough of what I ended up doing after finding various samples and snippets for the individual pieces.</p>

            <p>If you have any thoughts/suggestions/feelings/reckonings/anecdotes or otherwise, feel free to reach out on <a href="https://twitter.com/ChamookTweets">twitter</a> üôå</p>

        </section>


		</article>
		<footer class="page-footer">
			  <div class="container">
            <p>
				        <a href="../index.html">&lt;- maybe there's other stuff to read</a>
            </p>
			</div>
		</footer>
  </body>
</html>
